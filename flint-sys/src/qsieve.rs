/* automatically generated by rust-bindgen 0.70.1 */

use libc::*;
use crate::deps::*;
use crate::flint::*;
use crate::fmpz_types::*;


pub const QS_DEBUG: u32 = 0;
pub const BITS_ADJUST: u32 = 25;
pub const BLOCK_SIZE: u32 = 262144;
#[repr(C)]
pub struct prime_t {
    pub pinv: mp_limb_t,
    pub p: libc::c_int,
    pub size: libc::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of prime_t"][::std::mem::size_of::<prime_t>() - 16usize];
    ["Alignment of prime_t"][::std::mem::align_of::<prime_t>() - 8usize];
    ["Offset of field: prime_t::pinv"][::std::mem::offset_of!(prime_t, pinv) - 0usize];
    ["Offset of field: prime_t::p"][::std::mem::offset_of!(prime_t, p) - 8usize];
    ["Offset of field: prime_t::size"][::std::mem::offset_of!(prime_t, size) - 12usize];
};
impl Default for prime_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct fac_t {
    pub ind: mp_limb_signed_t,
    pub exp: mp_limb_signed_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of fac_t"][::std::mem::size_of::<fac_t>() - 16usize];
    ["Alignment of fac_t"][::std::mem::align_of::<fac_t>() - 8usize];
    ["Offset of field: fac_t::ind"][::std::mem::offset_of!(fac_t, ind) - 0usize];
    ["Offset of field: fac_t::exp"][::std::mem::offset_of!(fac_t, exp) - 8usize];
};
impl Default for fac_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct la_col_t {
    pub data: *mut mp_limb_signed_t,
    pub weight: mp_limb_signed_t,
    pub orig: mp_limb_signed_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of la_col_t"][::std::mem::size_of::<la_col_t>() - 24usize];
    ["Alignment of la_col_t"][::std::mem::align_of::<la_col_t>() - 8usize];
    ["Offset of field: la_col_t::data"][::std::mem::offset_of!(la_col_t, data) - 0usize];
    ["Offset of field: la_col_t::weight"][::std::mem::offset_of!(la_col_t, weight) - 8usize];
    ["Offset of field: la_col_t::orig"][::std::mem::offset_of!(la_col_t, orig) - 16usize];
};
impl Default for la_col_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct hash_t {
    pub prime: mp_limb_t,
    pub next: mp_limb_t,
    pub count: mp_limb_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of hash_t"][::std::mem::size_of::<hash_t>() - 24usize];
    ["Alignment of hash_t"][::std::mem::align_of::<hash_t>() - 8usize];
    ["Offset of field: hash_t::prime"][::std::mem::offset_of!(hash_t, prime) - 0usize];
    ["Offset of field: hash_t::next"][::std::mem::offset_of!(hash_t, next) - 8usize];
    ["Offset of field: hash_t::count"][::std::mem::offset_of!(hash_t, count) - 16usize];
};
impl Default for hash_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct relation_t {
    pub lp: mp_limb_t,
    pub num_factors: mp_limb_signed_t,
    pub small_primes: mp_limb_signed_t,
    pub small: *mut mp_limb_signed_t,
    pub factor: *mut fac_t,
    pub Y: fmpz_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of relation_t"][::std::mem::size_of::<relation_t>() - 48usize];
    ["Alignment of relation_t"][::std::mem::align_of::<relation_t>() - 8usize];
    ["Offset of field: relation_t::lp"][::std::mem::offset_of!(relation_t, lp) - 0usize];
    ["Offset of field: relation_t::num_factors"]
        [::std::mem::offset_of!(relation_t, num_factors) - 8usize];
    ["Offset of field: relation_t::small_primes"]
        [::std::mem::offset_of!(relation_t, small_primes) - 16usize];
    ["Offset of field: relation_t::small"][::std::mem::offset_of!(relation_t, small) - 24usize];
    ["Offset of field: relation_t::factor"][::std::mem::offset_of!(relation_t, factor) - 32usize];
    ["Offset of field: relation_t::Y"][::std::mem::offset_of!(relation_t, Y) - 40usize];
};
impl Default for relation_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct qs_poly_s {
    pub B: fmpz_t,
    pub soln1: *mut libc::c_int,
    pub soln2: *mut libc::c_int,
    pub posn1: *mut libc::c_int,
    pub posn2: *mut libc::c_int,
    pub small: *mut mp_limb_signed_t,
    pub factor: *mut fac_t,
    pub num_factors: mp_limb_signed_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of qs_poly_s"][::std::mem::size_of::<qs_poly_s>() - 64usize];
    ["Alignment of qs_poly_s"][::std::mem::align_of::<qs_poly_s>() - 8usize];
    ["Offset of field: qs_poly_s::B"][::std::mem::offset_of!(qs_poly_s, B) - 0usize];
    ["Offset of field: qs_poly_s::soln1"][::std::mem::offset_of!(qs_poly_s, soln1) - 8usize];
    ["Offset of field: qs_poly_s::soln2"][::std::mem::offset_of!(qs_poly_s, soln2) - 16usize];
    ["Offset of field: qs_poly_s::posn1"][::std::mem::offset_of!(qs_poly_s, posn1) - 24usize];
    ["Offset of field: qs_poly_s::posn2"][::std::mem::offset_of!(qs_poly_s, posn2) - 32usize];
    ["Offset of field: qs_poly_s::small"][::std::mem::offset_of!(qs_poly_s, small) - 40usize];
    ["Offset of field: qs_poly_s::factor"][::std::mem::offset_of!(qs_poly_s, factor) - 48usize];
    ["Offset of field: qs_poly_s::num_factors"]
        [::std::mem::offset_of!(qs_poly_s, num_factors) - 56usize];
};
impl Default for qs_poly_s {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type qs_poly_t = [qs_poly_s; 1usize];
#[repr(C)]
pub struct qs_s {
    pub index_j: mp_limb_signed_t,
    pub mutex: pthread_mutex_t,
    pub handles: *mut thread_pool_handle,
    pub num_handles: mp_limb_signed_t,
    pub n: fmpz_t,
    pub bits: mp_limb_t,
    pub ks_primes: mp_limb_t,
    pub k: mp_limb_t,
    pub kn: fmpz_t,
    pub num_primes: mp_limb_signed_t,
    pub factor_base: *mut prime_t,
    pub sqrts: *mut libc::c_int,
    pub small_primes: mp_limb_signed_t,
    pub second_prime: mp_limb_signed_t,
    pub sieve_size: mp_limb_signed_t,
    pub sieve_bits: libc::c_uchar,
    pub sieve_fill: libc::c_uchar,
    #[doc = "POLYNOMIAL DATA"]
    pub A: fmpz_t,
    pub B: fmpz_t,
    pub A_ind: *mut mp_limb_t,
    pub A_divp: *mut fmpz_t,
    pub B0_terms: *mut mp_limb_t,
    pub B_terms: *mut fmpz_t,
    pub A_inv: *mut mp_limb_t,
    pub A_inv2B: *mut *mut mp_limb_t,
    pub soln1: *mut libc::c_int,
    pub soln2: *mut libc::c_int,
    pub target_A: fmpz_t,
    pub upp_bound: fmpz_t,
    pub low_bound: fmpz_t,
    pub s: mp_limb_signed_t,
    pub low: mp_limb_signed_t,
    pub high: mp_limb_signed_t,
    pub span: mp_limb_signed_t,
    pub h: mp_limb_signed_t,
    pub m: mp_limb_signed_t,
    pub A_ind_diff: mp_limb_signed_t,
    pub curr_subset: *mut mp_limb_t,
    pub first_subset: *mut mp_limb_t,
    pub j: mp_limb_t,
    pub poly: *mut qs_poly_s,
    #[doc = "RELATION DATA"]
    pub siqs: *mut FLINT_FILE,
    pub fname: *mut libc::c_char,
    pub full_relation: mp_limb_signed_t,
    pub num_cycles: mp_limb_signed_t,
    pub vertices: mp_limb_signed_t,
    pub components: mp_limb_signed_t,
    pub edges: mp_limb_signed_t,
    pub table_size: mp_limb_signed_t,
    pub table: *mut hash_t,
    pub hash_table: *mut mp_limb_t,
    pub extra_rels: mp_limb_signed_t,
    pub max_factors: mp_limb_signed_t,
    pub Y_arr: *mut fmpz,
    pub curr_rel: *mut mp_limb_signed_t,
    pub relation: *mut mp_limb_signed_t,
    pub buffer_size: mp_limb_signed_t,
    pub num_relations: mp_limb_signed_t,
    pub small_factor: mp_limb_t,
    #[doc = "LINEAR ALGEBRA DATA"]
    pub matrix: *mut la_col_t,
    pub qsort_arr: *mut *mut la_col_t,
    pub columns: mp_limb_signed_t,
    #[doc = "SQUARE ROOT DATA"]
    pub prime_count: *mut mp_limb_signed_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of qs_s"][::std::mem::size_of::<qs_s>() - 528usize];
    ["Alignment of qs_s"][::std::mem::align_of::<qs_s>() - 8usize];
    ["Offset of field: qs_s::index_j"][::std::mem::offset_of!(qs_s, index_j) - 0usize];
    ["Offset of field: qs_s::mutex"][::std::mem::offset_of!(qs_s, mutex) - 8usize];
    ["Offset of field: qs_s::handles"][::std::mem::offset_of!(qs_s, handles) - 48usize];
    ["Offset of field: qs_s::num_handles"][::std::mem::offset_of!(qs_s, num_handles) - 56usize];
    ["Offset of field: qs_s::n"][::std::mem::offset_of!(qs_s, n) - 64usize];
    ["Offset of field: qs_s::bits"][::std::mem::offset_of!(qs_s, bits) - 72usize];
    ["Offset of field: qs_s::ks_primes"][::std::mem::offset_of!(qs_s, ks_primes) - 80usize];
    ["Offset of field: qs_s::k"][::std::mem::offset_of!(qs_s, k) - 88usize];
    ["Offset of field: qs_s::kn"][::std::mem::offset_of!(qs_s, kn) - 96usize];
    ["Offset of field: qs_s::num_primes"][::std::mem::offset_of!(qs_s, num_primes) - 104usize];
    ["Offset of field: qs_s::factor_base"][::std::mem::offset_of!(qs_s, factor_base) - 112usize];
    ["Offset of field: qs_s::sqrts"][::std::mem::offset_of!(qs_s, sqrts) - 120usize];
    ["Offset of field: qs_s::small_primes"][::std::mem::offset_of!(qs_s, small_primes) - 128usize];
    ["Offset of field: qs_s::second_prime"][::std::mem::offset_of!(qs_s, second_prime) - 136usize];
    ["Offset of field: qs_s::sieve_size"][::std::mem::offset_of!(qs_s, sieve_size) - 144usize];
    ["Offset of field: qs_s::sieve_bits"][::std::mem::offset_of!(qs_s, sieve_bits) - 152usize];
    ["Offset of field: qs_s::sieve_fill"][::std::mem::offset_of!(qs_s, sieve_fill) - 153usize];
    ["Offset of field: qs_s::A"][::std::mem::offset_of!(qs_s, A) - 160usize];
    ["Offset of field: qs_s::B"][::std::mem::offset_of!(qs_s, B) - 168usize];
    ["Offset of field: qs_s::A_ind"][::std::mem::offset_of!(qs_s, A_ind) - 176usize];
    ["Offset of field: qs_s::A_divp"][::std::mem::offset_of!(qs_s, A_divp) - 184usize];
    ["Offset of field: qs_s::B0_terms"][::std::mem::offset_of!(qs_s, B0_terms) - 192usize];
    ["Offset of field: qs_s::B_terms"][::std::mem::offset_of!(qs_s, B_terms) - 200usize];
    ["Offset of field: qs_s::A_inv"][::std::mem::offset_of!(qs_s, A_inv) - 208usize];
    ["Offset of field: qs_s::A_inv2B"][::std::mem::offset_of!(qs_s, A_inv2B) - 216usize];
    ["Offset of field: qs_s::soln1"][::std::mem::offset_of!(qs_s, soln1) - 224usize];
    ["Offset of field: qs_s::soln2"][::std::mem::offset_of!(qs_s, soln2) - 232usize];
    ["Offset of field: qs_s::target_A"][::std::mem::offset_of!(qs_s, target_A) - 240usize];
    ["Offset of field: qs_s::upp_bound"][::std::mem::offset_of!(qs_s, upp_bound) - 248usize];
    ["Offset of field: qs_s::low_bound"][::std::mem::offset_of!(qs_s, low_bound) - 256usize];
    ["Offset of field: qs_s::s"][::std::mem::offset_of!(qs_s, s) - 264usize];
    ["Offset of field: qs_s::low"][::std::mem::offset_of!(qs_s, low) - 272usize];
    ["Offset of field: qs_s::high"][::std::mem::offset_of!(qs_s, high) - 280usize];
    ["Offset of field: qs_s::span"][::std::mem::offset_of!(qs_s, span) - 288usize];
    ["Offset of field: qs_s::h"][::std::mem::offset_of!(qs_s, h) - 296usize];
    ["Offset of field: qs_s::m"][::std::mem::offset_of!(qs_s, m) - 304usize];
    ["Offset of field: qs_s::A_ind_diff"][::std::mem::offset_of!(qs_s, A_ind_diff) - 312usize];
    ["Offset of field: qs_s::curr_subset"][::std::mem::offset_of!(qs_s, curr_subset) - 320usize];
    ["Offset of field: qs_s::first_subset"][::std::mem::offset_of!(qs_s, first_subset) - 328usize];
    ["Offset of field: qs_s::j"][::std::mem::offset_of!(qs_s, j) - 336usize];
    ["Offset of field: qs_s::poly"][::std::mem::offset_of!(qs_s, poly) - 344usize];
    ["Offset of field: qs_s::siqs"][::std::mem::offset_of!(qs_s, siqs) - 352usize];
    ["Offset of field: qs_s::fname"][::std::mem::offset_of!(qs_s, fname) - 360usize];
    ["Offset of field: qs_s::full_relation"]
        [::std::mem::offset_of!(qs_s, full_relation) - 368usize];
    ["Offset of field: qs_s::num_cycles"][::std::mem::offset_of!(qs_s, num_cycles) - 376usize];
    ["Offset of field: qs_s::vertices"][::std::mem::offset_of!(qs_s, vertices) - 384usize];
    ["Offset of field: qs_s::components"][::std::mem::offset_of!(qs_s, components) - 392usize];
    ["Offset of field: qs_s::edges"][::std::mem::offset_of!(qs_s, edges) - 400usize];
    ["Offset of field: qs_s::table_size"][::std::mem::offset_of!(qs_s, table_size) - 408usize];
    ["Offset of field: qs_s::table"][::std::mem::offset_of!(qs_s, table) - 416usize];
    ["Offset of field: qs_s::hash_table"][::std::mem::offset_of!(qs_s, hash_table) - 424usize];
    ["Offset of field: qs_s::extra_rels"][::std::mem::offset_of!(qs_s, extra_rels) - 432usize];
    ["Offset of field: qs_s::max_factors"][::std::mem::offset_of!(qs_s, max_factors) - 440usize];
    ["Offset of field: qs_s::Y_arr"][::std::mem::offset_of!(qs_s, Y_arr) - 448usize];
    ["Offset of field: qs_s::curr_rel"][::std::mem::offset_of!(qs_s, curr_rel) - 456usize];
    ["Offset of field: qs_s::relation"][::std::mem::offset_of!(qs_s, relation) - 464usize];
    ["Offset of field: qs_s::buffer_size"][::std::mem::offset_of!(qs_s, buffer_size) - 472usize];
    ["Offset of field: qs_s::num_relations"]
        [::std::mem::offset_of!(qs_s, num_relations) - 480usize];
    ["Offset of field: qs_s::small_factor"][::std::mem::offset_of!(qs_s, small_factor) - 488usize];
    ["Offset of field: qs_s::matrix"][::std::mem::offset_of!(qs_s, matrix) - 496usize];
    ["Offset of field: qs_s::qsort_arr"][::std::mem::offset_of!(qs_s, qsort_arr) - 504usize];
    ["Offset of field: qs_s::columns"][::std::mem::offset_of!(qs_s, columns) - 512usize];
    ["Offset of field: qs_s::prime_count"][::std::mem::offset_of!(qs_s, prime_count) - 520usize];
};
impl Default for qs_s {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type qs_t = [qs_s; 1usize];
extern "C" {
    pub static mut qsieve_tune: [[mp_limb_t; 6usize]; 30usize];
    pub fn qsieve_init(qs_inf: *mut qs_s, n: *const fmpz);
    pub fn qsieve_knuth_schroeppel(qs_inf: *mut qs_s) -> mp_limb_t;
    pub fn qsieve_clear(qs_inf: *mut qs_s);
    pub fn qsieve_factor(factors: *mut fmpz_factor_struct, n: *const fmpz);
    pub fn compute_factor_base(
        small_factor: *mut mp_limb_t,
        qs_inf: *mut qs_s,
        num_primes: mp_limb_signed_t,
    ) -> *mut prime_t;
    pub fn qsieve_primes_init(qs_inf: *mut qs_s) -> mp_limb_t;
    pub fn qsieve_primes_increment(qs_inf: *mut qs_s, delta: mp_limb_t) -> mp_limb_t;
    pub fn qsieve_poly_init(qs_inf: *mut qs_s) -> mp_limb_t;
    pub fn qsieve_init_A(qs_inf: *mut qs_s) -> libc::c_int;
    pub fn qsieve_reinit_A(qs_inf: *mut qs_s);
    pub fn qsieve_next_A(qs_inf: *mut qs_s) -> libc::c_int;
    pub fn qsieve_init_poly_first(qs_inf: *mut qs_s);
    pub fn qsieve_init_poly_next(qs_inf: *mut qs_s, i: mp_limb_signed_t);
    pub fn qsieve_compute_C(C: *mut fmpz, qs_inf: *mut qs_s, poly: *mut qs_poly_s);
    pub fn qsieve_poly_copy(poly: *mut qs_poly_s, qs_inf: *mut qs_s);
    pub fn qsieve_poly_clear(qs_inf: *mut qs_s);
    pub fn qsieve_do_sieving(qs_inf: *mut qs_s, sieve: *mut libc::c_uchar, poly: *mut qs_poly_s);
    pub fn qsieve_do_sieving2(qs_inf: *mut qs_s, sieve: *mut libc::c_uchar, poly: *mut qs_poly_s);
    pub fn qsieve_evaluate_candidate(
        qs_inf: *mut qs_s,
        i: mp_limb_t,
        sieve: *mut libc::c_uchar,
        poly: *mut qs_poly_s,
    ) -> mp_limb_signed_t;
    pub fn qsieve_evaluate_sieve(
        qs_inf: *mut qs_s,
        sieve: *mut libc::c_uchar,
        poly: *mut qs_poly_s,
    ) -> mp_limb_signed_t;
    pub fn qsieve_collect_relations(
        qs_inf: *mut qs_s,
        sieve: *mut libc::c_uchar,
    ) -> mp_limb_signed_t;
    pub fn qsieve_linalg_init(qs_inf: *mut qs_s);
    pub fn qsieve_linalg_realloc(qs_inf: *mut qs_s);
    pub fn qsieve_linalg_clear(qs_inf: *mut qs_s);
    pub fn qsieve_relations_cmp(a: *const libc::c_void, b: *const libc::c_void) -> libc::c_int;
    pub fn qsieve_merge_relations(qs_inf: *mut qs_s) -> mp_limb_signed_t;
    pub fn qsieve_write_to_file(
        qs_inf: *mut qs_s,
        prime: mp_limb_t,
        Y: *const fmpz,
        poly: *const qs_poly_s,
    );
    pub fn qsieve_get_table_entry(qs_inf: *mut qs_s, prime: mp_limb_t) -> *mut hash_t;
    pub fn qsieve_add_to_hashtable(qs_inf: *mut qs_s, prime: mp_limb_t);
    pub fn qsieve_parse_relation(qs_inf: *mut qs_s) -> relation_t;
    pub fn qsieve_merge_relation(qs_inf: *mut qs_s, a: relation_t, b: relation_t) -> relation_t;
    pub fn qsieve_compare_relation(a: *const libc::c_void, b: *const libc::c_void) -> libc::c_int;
    pub fn qsieve_remove_duplicates(
        rel_list: *mut relation_t,
        num_relations: mp_limb_signed_t,
    ) -> libc::c_int;
    pub fn qsieve_insert_relation(
        qs_inf: *mut qs_s,
        rel_list: *mut relation_t,
        num_relations: mp_limb_signed_t,
    );
    pub fn qsieve_process_relation(qs_inf: *mut qs_s) -> libc::c_int;
    #[link_name = "insert_col_entry__extern"]
    pub fn insert_col_entry(col: *mut la_col_t, entry: mp_limb_signed_t);
    #[link_name = "swap_cols__extern"]
    pub fn swap_cols(col2: *mut la_col_t, col1: *mut la_col_t);
    #[link_name = "clear_col__extern"]
    pub fn clear_col(col: *mut la_col_t);
    #[link_name = "free_col__extern"]
    pub fn free_col(col: *mut la_col_t);
    pub fn get_null_entry(nullrows: *mut u64, i: mp_limb_signed_t, l: mp_limb_signed_t) -> u64;
    pub fn reduce_matrix(
        qs_inf: *mut qs_s,
        nrows: *mut mp_limb_signed_t,
        ncols: *mut mp_limb_signed_t,
        cols: *mut la_col_t,
    );
    pub fn block_lanczos(
        state: *mut flint_rand_s,
        nrows: mp_limb_signed_t,
        dense_rows: mp_limb_signed_t,
        ncols: mp_limb_signed_t,
        B: *mut la_col_t,
    ) -> *mut u64;
    pub fn qsieve_square_root(
        X: *mut fmpz,
        Y: *mut fmpz,
        qs_inf: *mut qs_s,
        nullrows: *mut u64,
        ncols: mp_limb_signed_t,
        l: mp_limb_signed_t,
        N: *mut fmpz,
    );
}
